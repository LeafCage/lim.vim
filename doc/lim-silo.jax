*lim-silo.txt*	簡易なデータベースのようなものを提供する。
*lim-silo*

==============================================================================
概要						*lim-silo-introduction*

テーブル1つの簡易なデータベースのようなものを提供する。これは silo と呼び、文
字列しか格納できず(文字列でない要素は文字列に変換される)、大きなデータの保持に
は向かない。これが向いているのはVimプラグインの少し込み入った設定を永続化する
ときである。データ効率を悪くしてでも総合的な速度の方を優先している。
|g:lim#silo#rootdir|で定義されるディレクトリ以下に silo で管理するデータのファ
イルが作成される。
使用実績) oreo.vim



==============================================================================
インターフェイス				*lim-silo-interface*

------------------------------------------------------------------------------
変数						*lim-silo-variables*


------------------------------------------------------------------------------
関数						*lim-silo-functions*

lim#silo#newSilo({name}, {fields}, [{behavior}])	*lim#silo#newSilo()*
	任意の silo名{name}とフィールド名を表すリスト{fields}を受け取り、Silo
	オブジェクトを返す。このとき{name}の silo が既に存在する場合はそれを読
	み込む。
	silo名{name}に "/" または "\" が含まれているのならそれはパスと見なされ
	、そのパスのファイルを siloファイルとする。そうでなければファイル名が
	silo名、ディレクトリ名が|g:lim#silo#rootdir|のパスになる。
	読込時、{fields}で渡されたフォーマットと、読み込まれたファイルのフォー
	マットが異なる場合、可能ならば古いフォーマットは新しいフォーマットに変
	更される。(新しいフィールドが追加されたならばそのフィールドには空文字
	列が入れられる。リネームされたと思われるフィールドが特定できるのならリ
	ネームをする。) 可能でないならばエラーメッセージを出し空のオブジェクト
	を返す(古いフィールドが削除されているときなど)。
	ファイルの読み書きはこの Siloオブジェクト作成時と、commitメソッド呼び
	出し時以外には行われない。Siloオブジェクトを作成してからcommitするまで
	が1つのトランザクションと見なすことも出来る。
	{fields}は空であってはならず、その要素は Vim の変数名として使えるもの
	すなわちアルファベットと数字とアンダーバーで構成されなければならず、数
	字が先頭に来てはならない。
	辞書{behavior}には追加のオプションを渡すことができる。以下のオプション
	を渡すことができる。
		key		(文字列)
			フィールド名を指定する。そのフィールドはキーフィールド
			と見なされ、Silo.nextkey()呼び出し時に利用される。

	Siloオブジェクトは以下のメソッドを持つ。


	Silo.is_changed()
	Silo が保持するレコードが、作成時から変更されたなら1、そうでなければ0
	を返す。


	Silo.commit([{rollback-filename}])
	Siloオブジェクトが持つrecordをファイルに書き込む。
	変更がないとき (is_changed() が 0 のとき) には書き込まずに1を返す。
	insert() や update() 等で変更を行ってもこれを呼ばないと実際に反映され
	ないので注意。
	{rollback-filename}を与えると、その名前のrollbackファイルも作成される
	。この名前に "/" または "\" が含まれているのならそれはパスと見なされる
	。そうでなければディレクトリが|g:lim#silo#rootdir|."/backup" のパスに
	なる。
	NOTE: この仕様はまだ固まっていない。


	Silo.has({where})
	条件{where}にマッチするレコードがあれば 1 なければ 0 を返す。{where}は
	辞書かリストか文字列である。
	辞書の場合、キーに{fields}で渡したフィールド名、値に正規表現パターンを
	指定する。ただしこの正規表現パターンに行頭行末記号 ^ $ は使えない。他
	にも使えないパターンがあるだろう。条件にマッチするレコードが検索される
	。|lim-silo-wherepattern|
	リストの場合は、その要素は insert() メソッドに渡す形式と同じである。そ
	れに完全一致するものが検索される。
	文字列の場合は、レコード内部表現を直接その文字列でマッチにかける。


	Silo.select({where}, [{fmt}])
	条件{where}にマッチするレコードのリストを返す。{where}は辞書である。
	辞書のキーはフィールド名で、{fields}で渡した要素のいずれかと一致しなく
	てはいけない。
	辞書の値は正規表現パターン文字列である。文字列以外は文字列に変換され
	る。has() メソッドのものと同じく、^ $ などのパターンが使えない。
	|lim-silo-wherepattern|
	{where}を空辞書にした場合、条件無しと見なされ、全てのレコードが返され
	る。
	{fmt}は文字列かリストである。{fmt}にリストを渡す場合
	|lim#silo#newSilo()|に渡した{fields}で指定した要素のうち任意のものを任
	意の順に並べたものである。select()の返り値であるレコードはこのフォーマ
	ットに従う。例えば >
		["field3", "field4", "field1"]
<	という{fmt}を渡すと、レコードはこの形式のリストになり、select()の返り
	値はリストインリストになる。
	{fmt}に文字列を指定すると、レコードは文字列になり、select()の返り値は
	リストインリストではなくなる。 >
		silo.select({}, ['alias', 'path'])
			#=> [['alias1', '/aaa/xxx'], ['alias2', '/bbb/yyy']]
		silo.select({}, ['alias'])
			#=> [['alias1'], ['alias2']]
		silo.select({}, 'alias')
			#=> ['alias1', 'alias2']
<	{fmt}が省略されるか空リストの時には順番そのままの全フィールドのレコー
	ド(リスト)が返される。


	Silo.select_distinct({where}, [{fmt}])
	select()と同じだが、重複レコードは除外されて返される。
	|misc|モジュール|lim#misc#uniq()|に依存する。


	Silo.select_grouped({where}, [{parent}, [{child}, [{grandchild}, ..]]])
	条件{where}にマッチするレコードのリストを返す。{where}は辞書であり、
	select()で指定するものと同じである。|lim-silo-wherepattern|
	結果を{parent}, {child}, {grandchild} .. に合わせて整形して返す。重複
	は除外される。{parent}, {child}, {grandchild} はフィールド名の文字列ま
	たはそれらのリストである。リストで指定されたフィールド名は一まとめにし
	て扱われる。
	|misc|モジュール|lim#misc#uniq()|に依存する。


	Silo.get({where}, [{fmt}])
	条件{where}に一番初めにマッチしたレコードを返す。マッチがない場合は空
	リスト/空文字を返す。{where}は辞書であり、select()で使われるものと同じ
	である。select()よりも高速であるため、一意な条件検索に向いている。


	Silo.exclude({where}, [{fmt}])
	select() メソッドが肯定なのに対しこれは否定で検索する。


	Silo.insert({record})
	Silo.insert({records})
	{record}が既に登録されているものと重複しないならばsiloに{record}を追加
	する。引数としてとれるのは、レコード{record}(文字列のリスト) か、レコ
	ーズ{records}(レコードのリスト、つまり文字列のリストのリスト) である。
	レコーズ{records}にした場合、複数レコードの登録ができる。
	レコードは文字列のリストであり、その順番や要素数は{fields}で渡した要素
	の順番や項目数と同数でなければならない。レコードの中に文字列でない要素
	が含まれていた場合でも、文字列に変換される。
	追加に成功したら0、失敗した場合、既に重複するレコードが登録されている
	のなら1、{record}の書き方がおかしいのなら2を返す。


	Silo.update({where}, {record})
	Silo.update({where}, {dict})
	siloから条件{where}にマッチするレコードを更新する。更新が成功したとき
	には0を返す。失敗したときには、既に登録されているレコードと重複する場
	合は1、条件にマッチするレコードが見つからなかったときには-1、条件がお
	かしいときには2を返す。
	す。第二引数はリストか辞書である。
	リスト{record}の場合はその順番や要素数は{fields}で渡した要素の順番や項
	目数と同数でなければならない。そして条件{where}がレコードを一意に定め
	るものでなければ更新は失敗する。
	辞書{dict}の場合はキーにフィールド名、値に変更後の文字列を指定する。


	Silo.delete({where})
	siloから条件{where}にマッチするレコードを削除する。{where}は辞書または
	リストである。
	リストの場合は、その要素は Silo.insert() メソッドに渡す形式と同じであ
	る。それに完全一致するものが検索される。


	Silo.sort([{func}])
	自身を返す。レコードをソートする。{func}には|sort()|で使われるのと同じ
	ものを利用できる。どのレコードの値をソート時に優先するかを指定したい場
	合は、Silo.rearrange() でフィールドの並びを変更すること。


	Silo.nextkey([{field}])
	フィールド名{field}のレコードの中で最大のものに1を加えた数を返す。この
	フィールドのレコードは数字で構成されている必要がある。
	insert() や update() delete() 等のsiloを変更するメソッドが呼ばれていな
	い限り、このnextkey()を呼ぶ度に返される数値が +1 されていく。
	Silo初期化時に{behavior}に "key" を渡しているのなら、{field}を省略する
	ことができる。


	Silo.set_nextkey([{field},] {val})
	次に nextkey() を呼んだときに返される値が{val}になる。
	Silo初期化時に{behavior}に "key" を渡しているのなら、{field}を省略する
	ことができる。


	Silo.rearrange({destfields})
	フィールドのリスト{destfields}の順にフィールドの並び順を変更する。自身
	を返す。


==============================================================================
特記事項					*lim-silo-specialnotes*

WHERE PATTERN					*lim-silo-wherepattern*

Silo.has() や Silo.select() で使える、辞書を使った条件の書き方について特記する
。この辞書のキーにはフィールド名を指定し、値に正規表現文字列を指定するが、この
正規表現は内部的な事情により、通常のものと仕様が異なる。
.* や .\+ は通常最長一致となるところ、ここでは最短一致になる。
キーにするフィールド名に ! を前置するとその要素は否定となる。その場合、値のパ
ターンにマッチしないものが選ばれる。

==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:
