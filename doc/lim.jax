*lim.txt*	Vimのライブラリ。oreo.vimで組み込む前提だが単体でも利用可能。

Author  : LeafCage <leafcage+vim @ gmail.com>
License : [NYSL](http://www.kmonos.net/nysl/index.en.html)
	Japanese original text: <http://www.kmonos.net/nysl/>

==============================================================================
目次						*lim-contents*

概要				|lim-introduction|
使い方				|lim-usage|
モジュール			|lim-modules|
  cmddef			  |lim-modules-cmddef|
  ui				  |lim-modules-ui|
  silo				  |lim-modules-silo|
  str2vimkeybind		  |lim-modules-str2vimkeybind|
  misc				  |lim-modules-misc|


==============================================================================
概要						*lim-introduction*

*lim*

最新版:
https://github.com/LeafCage/lim.vim


==============================================================================
使い方						*lim-usage*



==============================================================================
モジュール					*lim-modules*

------------------------------------------------------------------------------
lim-modules-cmddef				*lim-modules-cmddef*

ユーザ定義コマンド|user-commands|作成時に有用なモジュール。
使用実績) flashcards.vim, oreo.vim

						*lim#cmdcmpl#newCmdcmpl()*
lim#cmdcmpl#newCmdcmpl({cmdline}, {cursorpos}, [{funcopts}])
	これはコマンド補完関数|:command-completion-customlist|内で利用し、コマ
	ンド補完関数の引数 CmdLine と CursorPos を{cmdline} {cursorpos}に渡し
	て使用する。
	コマンド補完関数作成を補助するオブジェクトCmdcmplを返す。
	省略可能な引数{funcopts}は辞書であり、次のキーを持たせることができる。
	--------~
	optpat		(文字列)
		コマンド引数のうちオプションとして解釈されるものを表すパターン
		。'^-' だと '-' で始まるものがコマンドオプションと見なされる。

	conflicts	(リストインリスト)
		文字列のリストインリストで同時に指定することが出来ない引数のグ
		ループを指定する。"--foo" ("-f") と "--bar" ("-r") と "--baz"
		("-z") が同時指定できない場合、次のように指定する。 >
			[["--foo", "--bar", "--baz", "-f", "-r", "-z"]]
<		また、そうでなくても単純にショートネームの定義として利用するこ
		とも出来る。 >
			[["--foo", "-f"], ["--bar", "-r"], ["--baz", "-z"]]
<
	Cmdcmplオブジェクトは以下のメソッドを持つ。
	--------~
	get_ordinal([{ignorepat}])
	現在の引数が先頭から数えて何番目の引数であるかを返す。
	n番目の引数に専用の候補を用意したいときに役立つ。
	{ignorepat}で指定されたパターンにマッチする引数は無視して数えられる。
	{ignorepat}が指定されていない場合、{funcopts}に optpat が指定されてい
	る場合はそれが使われる。{ignorepat}が空文字の場合は指定なしとして扱わ
	れる。 >
		:Cmd --opt1 arg1 arg2
<	で{cursorpos}が16のとき(arg1の後の空白にカーソルがあるとき)、
	{ignorepat}が '^-' だと結果が2になる。{ignorepat}が指定なしならば3。
	これは - で始まる引数はオプションとして無視したいときなどに役立つ。

	should_complete_options()
	{funcopts}にキー optpat が渡されている必要がある。
	現在のArgleadが optpat パターンにマッチすれば1を返す。

	is_matched({pat})
	現在のArgleadがパターン{pat}にマッチすれば1を返す。

	get_arg({pat}, [[{default},] {ordinal}])
	入力済みのコマンドライン文字列から{pat}に一番初めにマッチした文字列を
	返す。マッチするものがなければ{default}を返す。
	1～9までの数値{ordinal}を渡すとカッコ|\(\)|でまとめられたパターンから
	その番目のマッチ返す。0を渡すと|matchlist()|のようにマッチのリストを返
	す。

	mill_candidates({candidates}, [{funcopts}])
	{candidates}はリストであり、 ["cand1", "cand2", "cand3"] のように補完
	候補を並べたものである。文脈に即して補完候補を絞り込んだリストを返す
	(このとき{candidates}が直接変更される。変更したくない場合は事前に
	|copy()|しておくこと)。
	省略可能な引数{funcopts}(辞書)は次のキーを持つことが出来る。
	--------~
	conflicts	(リストインリスト)
		既定値: []
		|lim#cmdcmpl#newCmdcmpl()|の{funcopts}で使われるものと同じであ
		る。省略されると|lim#cmdcmpl#newCmdcmpl()|の{funcopts}で渡され
		たものが使われる。同時に指定することが出来ない引数をリストでグ
		ループ化して指定する。
	reuses		(リスト/数値)
		既定動作では既にコマンドラインに入力済みの引数は再び補完候補に
		なることはないが、このリスト内の文字列については再利用が許され
		る。また、非0の数値が渡された場合全ての候補が再利用される。


						*lim#cmddef#parse_options()*
lim#cmddef#parse_options({args}, {optdict}, [{switchdict}, [{funcopts}]])
	オプション付きのコマンドを実行するときに、ユーザがどのようなオプション
	引数を渡したかを解釈する。コマンドライン引数のリスト{args}からオプショ
	ンと思しきものを除去した後、2つの辞書{optdict} {switchdict}に結果を反
	映して返す。
	初期設定ではオプション引数は "--" で始まり、続く文字がアルファベットと
	数字と "-" で構成された文字列で、 --opt=val の形で値を設定することがで
	きる。スイッチ引数は "-" で始まりアルファベットと数字で構成された文字
	列で、 -s=val の形で値を設定することができ、また -abc の形で複数のスイ
	ッチ a b c を1つの引数で渡すことができる。
	{optdict}のキーには期待されるオプション名 (先頭に付ける文字 "--" を省
	く) を、値にはその初期値を設定する。
	{switchdict}のキーには期待されるスイッチ名 (先頭に付ける文字 "-" を省
	く) を、値にはその初期値を設定する。省略された場合、空辞書として扱われ
	る。
	{optdict} {switchdict}にない引数が渡された場合、初期設定ではエラーメッ
	セージを表示する。

	省略可能な引数{funcopts}(辞書)でこの挙動を変更することができる。
	{funcopts}は次のキーを持つことができる。
	--------~
	optionpat	(文字列)
		既定値: '\m^--\([[:alnum:]-]\+\)\%(=\(.*\)\)\?'
		引数がこのパターンにマッチするとオプション引数と見なされる。
		オプション名は丸括弧|\(\)|でまとめる必要がある。
		また、オプションが引数を取るのならその値は2つめの丸括弧でまと
		めなければいけない。
	switchpat	(文字列)
		既定値: '\m^-\([[:alnum:]]\+\)\%(=\(.*\)\)\?'
		引数がこのパターンにマッチするとスイッチ引数と見なされる。
		スイッチ名は丸括弧|\(\)|でまとめる必要がある。
		また、スイッチが引数を取るのならその値は2つめの丸括弧でまとめ
		なければいけない。
	suppresserr	(数値)
		既定値: 0
		非0 の場合、渡された引数が{optdict} {switchdict}のキーに含まれ
		ていなくてもエラーメッセージを出さない。


------------------------------------------------------------------------------
lim-modules-ui					*lim-modules-ui*

						*lim#ui#select()*
lim#ui#select({prompt}, {choices}, [{funcopts}])
	複数の選択肢の中から1つを選ばせるインターフェイスである。
	{prompt}でメッセージを表示し、選択肢{choices}から1つをユーザに入力させ
	て選ばせ結果を返す。キャンセル|cancel_inputs|されると空リストを返す。

	{choices}には複数の書き方があるが、もっとも単純なものは以下の形式の
	辞書である。
	{ key-define1: caption1, key-define2: caption2, ...} >
		{"a": "foo", "b": "bar", "c1": "baz", "c2": "qux"}
<	この場合、"a : foo" "b : bar" "c1 : baz" "c2 : qux" という選択肢が示さ
	れ、例えば "b" を入力すると ["b", "baz"] というリストが返される。"c1"
	"c2" のような複数ストローク選択肢は選択が一意になるまで入力を受け取る
	。
	{choices}はリストでもよく、その場合はリストのリストで、次のように定義
	する。
	[ [key-define1, caption1], [key-define2, caption2], ...]
	辞書の場合と違って選択肢の並びを自由に設定できる。その場合、先ほどの例
	は、 >
		[["a", "foo"], ["b", "bar"], ["c1", "baz"], ["c2", "qux"]]
<	となる。

	また、リストのリストは第3要素以降を持つことが出来る。 >
		[["a", "foo"], ["b", "bar", {"hoge": 6}],
		\ ["c1", "baz", "L"], ["c2", "qux", ["piyo"], {"fuga": 44}]]
<	第3要素以降はどのような型でも良い。これらは処理上は無視されるが、返り
	値には現れる。

	また、選択肢の caption 部分は文字列だけでなく辞書やリストでも定義する
	ことが出来る。辞書で持たせる場合、関数の戻り値の第2要素はこの辞書の
	captionキーの値である(未定義なら空文字)。
	辞書には次のキーを持たせてもよい。
	--------~
	caption		(文字列)
		選択肢として表示される説明部分の文字。未定義の場合、その候補は
		選択肢に表示されない。選択は可能。
	is_hidden	(数値)
		既定値: 0
		非0 ならこの候補は選択肢に表示されない。選択は可能。
		caption キーを省いた場合と同じである。
	throw		(文字列)
		この選択肢が選ばれたときに、この文字列の例外を投げる。
	--------~
	この形式を使った{choices}の書き方はリストの場合以下のようになる。 >
		[
		\ ["a", {"caption": "foo"}],
		\ ["b", "bar"],
		\ ["\<C-a>", {"caption": "push <C-a>", "throw": "CTRL-A"}],
		\ ["q", {"caption": "qux", "is_hidden": 1}],
		\ ["r", {}],
		]
<	この場合、選択肢に "q" "r" は表示されないが選択は出来る。また、<C-a>
	を選択すると例外 "CTRL-A" が投げられる。

	captionをリストにする場合、リストの第1要素がcaptionとして扱われ、第2引
	数以降は処理上無視されるが、戻り値には第3引数以降として現れる。 >
		{
		\ "a": [{"caption": "foo"}, "Alice"],
		\ "b": ["bar", "Bob"],
		\ "\<C-a>": {"caption": "push <C-a>", "throw": "CTRL-A"},
		\ "q": [{"caption": "qux", "is_hidden": 1}, "Fred"],
		\ "r": {},
		}

<	省略可能な辞書{funcopts}(辞書)で関数の挙動を変更できる。
	--------~
	show_choices		(数値)
		既定値: 1
		0 にすると選択肢を表示しない。
	cancel_inputs		(リスト)
		既定値: ["\<Esc>"]
		このリストにある入力を受け取った場合、選択をキャンセルして関数
		を抜ける。安全のためにこのリストに必ず "\<C-c>" が加えられる。
		{choices}よりも優先される。戻り値は [] になる。
	throw_on_canceled	(数値/リスト)
		既定値: 0
		非0 にすると cancel_inputs が押されてキャンセルされる時に
		"select: canceled" の例外が投げられる。
		リストにすると、リストに定義されている要素の入力の時だけ例外が
		投げられる。例えば ["\<C-c>"] と定義されていた場合、<Esc>で抜
		けたときには例外が投げられない。<C-c>の時だけ投げられる。


lim#ui#keybind({binddefs})			*lim#ui#keybind()*


------------------------------------------------------------------------------
lim-modules-silo				*lim-modules-silo*

簡易なデータベースを提供する。これは silo と呼び、文字列しか格納できず、1つの
データベースが複数のテーブルを持つことはない。保持するレコードを全てメモリに読
み込むので大きなデータを収めるのには向いていない。
Vimプラグインの少し込み入った設定を永続化するのに利用できる。
|g:lim#silo#rootdir|で定義されるディレクトリ以下に silo で管理するデータのファ
イルが作成される。
使用実績) oreo.vim

lim#silo#newSilo({name}, {fields})		*lim#silo#newSilo()*
	任意の silo名{name}とフィールド名を表すリスト{fields}を受け取り、Silo
	オブジェクトを返す。このとき{name}の silo が既に存在する場合はそれを読
	み込む。
	ファイルの読み書きはこの Siloオブジェクト作成時と、commitメソッド呼び
	出し時以外には行われない。Siloオブジェクトを作成してからcommitするまで
	が1つのトランザクションと見なすことも出来る。
	{fields}は空であってはならず、その要素は Vim の変数名として使えるもの
	すなわちアルファベットと数字とアンダーバーで構成されなければならず、数
	字が先頭に来てはならない。
	定義を変更したときには|lim#silo#alter()|などでデータファイル側も更新
	すること。

	Siloオブジェクトは以下のメソッドを持つ。

	is_changed()
	Silo が保持するレコードが、作成時から変更されたかどうかを返す。

	commit([{rollback-filename}])
	Siloオブジェクトが持つrecordをファイルに書き込む。
	変更がないとき (is_changed() が 0 のとき) には書き込まない。
	insert() や update() 等で変更を行ってもこれを呼ばないと実際に反映され
	ないので注意。
	{rollback-filename}を与えると、その名前のrollbackファイルも作成される
	。
	これは|lim#silo#rollback()|で変更を取り消しできる。

	has({where})
	条件{where}にマッチするレコードがあれば 1 なければ 0 を返す。{where}は
	辞書かリストか文字列である。
	辞書の場合、キーに{fields}で渡したフィールド名、値に正規表現パターンを
	指定する。ただしこの正規表現パターンに行頭行末記号 ^ $ は使えない。他
	にも使えないパターンがあるだろう。条件にマッチするレコードが検索される
	。
	リストの場合は、その要素は insert() メソッドに渡す形式と同じである。そ
	れに完全一致するものが検索される。
	文字列の場合は、レコード内部表現を直接その文字列でマッチにかける。

	select({where}, [{fmt}])
	条件{where}にマッチするレコードのリストを返す。{where}は辞書である。
	辞書のキーはフィールド名で、{fields}で渡した要素のいずれかと一致しなく
	てはいけない。
	辞書の値は正規表現パターン文字列である。has() メソッドのものと同じく、
	^ $ などのパターンが使えない。
	{where}を空辞書にした場合、条件無しと見なされ、全てのレコードが返され
	る。
	{fmt}は{fields}で指定した要素のうち任意のものを任意の順に並べたリスト
	であり、select()の返り値であるレコードはこの形式に従う。例えば >
		["field3", "field4", "field1"]
<	という{fmt}を渡すと、レコードはこの形式のリストになり、select()の返り
	値はリストインリストになる。また{fmt}の要素数が1の場合、レコードは文字
	列になり、select()の返り値はリストインリストではなくなる。。
	{fmt}が省略されるか空リストの時には順番そのままの全フィールドのレコー
	ド(リスト)が返される。

	select_distinct({where}, [{fmt}])
	select()と同じだが、重複レコードは除外されて返される。
	|misc|モジュール|lim#misc#uniqify()|に依存する。

	exclude({where}, [{fmt}])
	select() メソッドが肯定なのに対しこれは否定で検索する。

	insert({record})
	siloに{record}を追加する。{record}はリストであり、その要素数は{fields}
	で渡した項目数と同数でなければならない。自身を返す。

	delete({where})
	siloから条件{where}にマッチするレコードを削除する。{where}は辞書または
	リストである。
	リストの場合は、その要素は insert() メソッドに渡す形式と同じである。そ
	れに完全一致するものが検索される。

	sort([{func}])
	レコードをソートする。{func}には|sort()|で使われるのと同じものを利用で
	きる。自身を返す。どのレコードの値をソート時に優先するかを指定したい場
	合は、rearrange() メソッドでフィールドの並びを変更すること。

	rearrange({destfields})
	フィールドのリスト{destfields}の順にフィールドの並び順を変更する。自身
	を返す。


------------------------------------------------------------------------------
lim-modules-str2vimkeybind			*lim-modules-str2vimkeybind*

				*lim#str2vimkeybind#str2vimkeybind()*
lim#str2vimkeybind#str2vimkeybind({stroke})
	文字列{stroke}の内、"<CR>" や "<C-a>" など、Vim のヘルプで使われるキー
	バインド表記で表すことができるものがあるのならそれに置き換える。
	文字列を返す。


------------------------------------------------------------------------------
lim-modules-misc				*lim-modules-misc*

汎用のモジュールを提供する。

--------------------------------------
Vim:

lim#misc#get_sid([{path}])			*lim#misc#get_sid()*
	Vim script{path}の script id を返す。{path}を省略した場合、現在開いて
	いるファイルで検索される。マッチがなければ 0 を返す。


lim#misc#match_sids({pat})			*lim#misc#match_sids()*
	パターン{pat}にマッチする script id をリストで返す。


lim#misc#get_scriptname({sid})			*lim#misc#get_scriptname()*


--------------------------------------
Data:

lim#misc#uniqify({list})			*lim#misc#uniqify()*
	{list}内の重複した要素を除去し、結果を返す。{list}を直接変更するので、
	必要なら事前に|copy()|をしておくこと。


--------------------------------------
System:

lim#misc#path_encode({path})			*lim#misc#path_encode()*
	パス名{path}をファイル名として使える名前に変更する。
	= を == に、: を =+ に、/ や \ を =- に変換した結果を返す。


lim#misc#path_decode({fname})			*lim#misc#path_decode()*
	|lim#misc#path_encode()|で変換したパス名を元に戻した結果を返す。


		*lim#misc#get_plugins_root_and_name_and_actualname()*
lim#misc#get_plugins_root_and_name_and_actualname({path})
	Vim plugin の 1ファイル{path}が所属するプラグインの名前とルートディレ
	クトリを推測して返す。ルートディレクトリはその直下には "after"
	"autoload" "plugin" "syntax" "ftplugin" "ftdetect" のうちのいずれかが
	あるだろうという乱暴な理論に基づいて{path}を遡りながら推測される。
	プラグイン名は、見つけたルートディレクトリの名前がすなわちプラグイン名
	だろうという乱暴な理論に基づき推測される。
	ただし、実際にはルートディレクトリ名がプラグイン名を表していない場合も
	あるので plugin, syntax, autoload ディレクトリにある実際の Vim script
	ファイル名を見てそれもプラグイン名の候補 actualname として返す。
	[rootpath, pluginname, actualname] というリストを返す。




==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:
