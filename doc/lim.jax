*lim.txt*	Vimのライブラリ。oreo.vimで組み込む前提だが単体でも利用可能。

Author  : LeafCage <leafcage+vim @ gmail.com>
License : [NYSL](http://www.kmonos.net/nysl/index.en.html)
	Japanese original text: <http://www.kmonos.net/nysl/>

==============================================================================
目次						*lim-contents*

概要				|lim-introduction|
使い方				|lim-usage|
モジュール			|lim-modules|
  cmddef			  |lim-modules-cmddef|
  ui				  |lim-modules-ui|
  silo				  |lim-modules-silo|
  str2vimkeybind		  |lim-modules-str2vimkeybind|
  misc				  |lim-modules-misc|


==============================================================================
概要						*lim-introduction*

*lim*

最新版:
https://github.com/LeafCage/lim.vim


==============================================================================
使い方						*lim-usage*



==============================================================================
モジュール					*lim-modules*

------------------------------------------------------------------------------
lim-modules-cmddef				*lim-modules-cmddef*

ユーザ定義コマンド|user-commands|作成時に有用なモジュール。
使用実績) flashcards.vim, oreo.vim

						*lim#cmdcmpl#newCmdcmpl()*
lim#cmdcmpl#newCmdcmpl({cmdline}, {cursorpos}, [{funcopts}])
	これはコマンド補完関数|:command-completion-customlist|内で利用し、コマ
	ンド補完関数の引数 CmdLine と CursorPos を{cmdline} {cursorpos}に渡し
	て使用する。
	コマンド補完関数作成を補助するオブジェクトCmdcmplを返す。
	省略可能な引数{funcopts}は辞書であり、次のキーを持たせることができる。
	--------~
	optbgnpat			(文字列)
		既定値: '^--\?'
		コマンド引数のうちこのパターンで始まるものはコマンドオプション
		として解釈される。

	conflicts		(リストインリスト)
		文字列のリストインリストで同時に指定することが出来ない引数のグ
		ループを指定する。"--foo" ("-f") と "--bar" ("-r") と "--baz"
		("-z") が同時指定できない場合、次のように指定する。 >
			[["--foo", "--bar", "--baz", "-f", "-r", "-z"]]
<		また、そうでなくても単純にショートネームの定義として利用するこ
		とも出来る。 >
			[["--foo", "-f"], ["--bar", "-r"], ["--baz", "-z"]]
<
	================~
	Cmdcmplオブジェクトは以下の変数とメソッドを持つ。
	変数は変更可能だが、そうすると各メソッドの結果が変化するかもしれない。
	--------~
	arglead			(文字列)
		補完対象の文字列。

	preword			(文字列)
		|arglead|の1つ前の入力文字列。

	beens			(リスト)
		既に入力されているコマンドライン文字列を引数ごとに区切ってリス
		ト化したもの。
	--------~
	get_settledqt([{ignorepat}])
	行頭からカーソル位置までにいくつ完成した引数をそのコマンドが持ってるか
	を返す。現在入力補完中の引数は数に含めない。1番目の引数を補完中なら、0
	を返す。
	{ignorepat}で指定されたパターンにマッチする引数は無視して数えられる。
	{ignorepat}が指定されていない場合、{funcopts}の optbgnpat に非空白文字
	が続くものが使われる。 >
		:Cmd --opt1 arg1 arg2
<	で{cursorpos}が16のとき(arg1の後の空白にカーソルがあるとき)、
	{ignorepat}が '^-' だと結果が1になる。{ignorepat}が指定なしならば2。
	これは - で始まる引数はオプションとして無視したいときなどに役立つ。
	ちなみに 内部変数について、self.trackwords[self.get_settledqt()]
	は self.preword に、get(self.beens, self.get_settledqt(), '') は
	self.argleadに一致する。

	should_optcmpl()
	現在のArgleadが{funcopts}の optbgnpat パターンにマッチすれば1を返す。

	is_matched({pat})
	現在のArgleadがパターン{pat}にマッチすれば1を返す。

	match_arg({pat}, [{default}])
	match_arg({list}, [{idx}, [{default}]])
	コマンドライン全体の単語 から正規表現{pat}に一番初めにマッチした文字列
	を返す。マッチするものがなければ{default}を返す。
	第一引数がリスト{list}の場合、いずれかの要素に一致するものを返す。
	{idx}が指定された場合、マッチした結果からそのindexの要素を返す。

	match_args({pat})
	コマンドライン全体の単語から正規表現{pat}にマッチしたもの全てをリスト
	にして返す。{pat}がリストの場合、いずれかの要素に一致するもの全てを返
	す。

	match_leftarg({pat}, [{default}])
	match_leftarg({list}, [{idx}, [{default}]])
	カーソルより左のコマンドラインの単語から正規表現{pat}に一番初めにマッ
	チした文字列を返す。マッチするものがなければ{default}を返す。
	第一引数がリスト{list}の場合、いずれかの要素に一致するものを返す。
	{idx}が指定された場合、マッチした結果からそのindexの要素を返す。

	match_leftargs({pat})
	カーソルより左のコマンドラインの単語から正規表現{pat}にマッチしたもの
	全てをリストにして返す。{pat}がリストの場合、いずれかの要素に一致する
	ものを全て返す。

	mill_conflicted({candidates}, [{conflicts}])
	補完候補のリスト{candidates}から、コンフリクトしている要素を取り除く。
	コンフリクトは引数をグループ化したリストのリスト{conflicts}で表される
	。"--open" と "--close"、"--foo" と "-f" が排他的関係にあるとき以下の
	ように表現する。 >
		[["--open", "--close"], ["--foo", "-f"]]
<	{conflicts}省略時には|lim#cmdcmpl#newCmdcmpl()|の{funcopts}で渡した
	conflicts が利用される。それもないときや、{conflicts}が空の時には何も
	起こらない。

	mill_inputed({candidates}, [{reuses}])
	補完候補のリスト{candidates}から、すでにコマンドラインに入力されている
	引数を取り除く。再利用リスト{reuses}にある要素はこの処理から除かれる。

	mill_by_arglead({candidates})
	補完候補のリスト{candidates}から、arglead にマッチしない要素を取り除く
	。argleadは現在補完対象になっている文字列である。

	mill_candidates({candidates}, [{conflicts}, [{reuses}]])
	補完候補のリスト{candidates}に、mill_conflicted()、mill_inputed()、
	mill_by_arglead()を全て実行した結果を返す。{conflicts}は省略時は
	|lim#cmdcmpl#newCmdcmpl()|の{funcopts}で渡した conflicts が利用され、
	それがないときや{conflicts}が空の時にはコンフリクト除外処理は行われな
	い。{reuses}は省略時は空リストで、これは mill_inputed() でコマンドライ
	ンに既に入力されている引数を全て取り除くようにするが、{reuses}に1を指
	定すると mill_inputed() がスキップされ、全ての引数の重複が許されるよう
	になる。


						*lim#cmdcmpl#newCmdParser()*
lim#cmdcmpl#newCmdParser({args}, [{funcopts}])
	コマンド実行時に渡された引数を解釈するパーサ CmdParser を返す。{args}
	はコマンド引数を単語で区切ってリスト化させたものである。
	省略可能な引数{funcopts}は辞書であり、次のキーを持たせることができる。
	----------------~
	longbgnpat		(文字列)
		既定値: "--"
		オプション引数の頭に付く文字列。引数先頭文字がこれにマッチすれ
		ばオプション引数と見なされる。

	shortbgnpat		(文字列)
		既定値: "-"
		一文字オプション引数の頭に付く文字列。一文字オプションはこれに
		続けて複数を一度に指定することができる。

	assignpat		(文字列)
		既定値: "="
		値を取るオプションが利用する代入記号

	================~
	CmdParser パーサは以下の変数とメソッドを持つ。
	--------~
	args			(リスト)
		初期化時に渡されたコマンドライン引数リスト{args}。後記のメソッ
		ドの副作用で幾つかの要素が削除されるかもしれない。

	args_original		(リスト)
		初期化時に渡されたままの args。args と違ってメソッドの副作用を
		受けない。
	--------~
	match_arg({pat}, [{default}])
	match_arg({list}, [{idx}, [{default}]])
	コマンドライン引数から正規表現{pat}に一番初めにマッチした文字列を返す
	。マッチするものがなければ{default}を返す。
	第一引数がリスト{list}の場合、いずれかの要素に一致するものを返す。
	{idx}が指定された場合、マッチした結果からそのindexの要素を返す。

	match_args({pat})
	コマンドライン引数から{pat}にマッチしたもの全てをリストにして返す。
	{pat}がリストの場合、いずれかの要素に一致するもの全てを返す。

	filter({string})
	{string}は|filter()|で使われるフィルタパターンと同じである。
	args から {string} の評価が 0 の要素を取り除く (v:val にはargs の各要
	素が代入される)。args を返す。

	parse_options({optdict})
	どのようなオプション引数が使われたのかを解釈する。args の各要素から
	{optdict}で指定されたパターンにマッチするものを評価し、オプション引数
	として評価された要素は args から取り除かれる。
	{"opt1": "val1", "opt2": "val2", ...} という形の結果が返される。
	{optdict}は辞書であり、キーにオプション名、値に文字列・数値か、辞書を
	指定する。
	文字列・数値の場合は、それがそのオプションの既定値と見なされる。
	辞書の場合はそれは以下のキーを持つことが出来る。
	--------~
	default			(文字列/数値)
		既定: 0
		オプションが省かれた場合の既定値を指定する。数値が渡された場合
		、そのオプションは真偽値タイプと見なされる。

	pats			(文字列のリスト)
		既定値: リストであり、{optdict}のキーの前方に "--" を付けたも
			のが要素として加えられる
		このパターンにマッチした引数はキーのオプション名のオプションと
		見なされる。
		"foo" という名前のオプションが、--foo というパターンで指定され
		、その省略形が -f である場合、以下のようになる。 >
			{'foo': {'pats': ["--foo", "-f"]}}
<

						*lim#cmddef#parse_options()*
lim#cmddef#parse_options({args}, {optdict}, [{funcopts}])
	オプション付きのコマンドを実行するときに、ユーザがどのようなオプション
	引数を渡したかを解釈する。{args}はリストであり、コマンドライン引数を単
	語で区切ってリスト化させたものである。この関数は副作用として{args}から
	解釈したオプション引数を取り除く。
	{optdict}は辞書であり、キーにオプション名、値に文字列・数値か、辞書を
	指定する。
	文字列・数値の場合は、それがそのオプションの既定値と見なされる。
	辞書の場合はそれは以下のキーを持つことが出来る。
	--------~
	default			(文字列/数値)
		既定: 0
		オプションが省かれた場合の既定値を指定する。数値が渡された場合
		、そのオプションは真偽値タイプと見なされる。

	pats			(文字列のリスト)
		既定値: {optdict}のキーの前方に "--" を付けたものが加えられる
		このパターンにマッチした引数はそのオプションだと見なされる。
		--foo の省略形が -f である場合、以下のようになる。 >
			["--foo", "-f"]

<	choices			(文字列のリスト)
		これが指定された場合、オプションの引数はここにあるもの以外だと
		エラーが出る。

	省略可能な引数{funcopts}(辞書)でこの挙動を変更することができる。
	{funcopts}は次のキーを持つことができる。
	--------~
	longbgnpat	(文字列)
		既定値: "--"
		オプション引数の頭に付く文字列。引数先頭文字がこれにマッチすれ
		ばオプション引数と見なされる。
	shortbgnpat	(文字列)
		既定値: "-"
		一文字オプション引数の頭に付く文字列。一文字オプションはこれに
		続けて複数を一度に指定することができる。
	assignpat	(文字列)
		既定値: "="
		値を取るオプションが利用する代入記号


------------------------------------------------------------------------------
lim-modules-ui					*lim-modules-ui*

						*lim#ui#select()*
lim#ui#select({prompt}, {choices}, [{funcopts}])
	複数の選択肢の中から1つを選ばせるインターフェイスである。
	{prompt}でメッセージを表示し、選択肢{choices}から1つをユーザに入力させ
	て選ばせ結果を返す。キャンセル|cancel_inputs|されると空リストを返す。

	{choices}には複数の書き方があるが、もっとも単純なものは以下の形式の
	辞書である。
	{ key-define1: caption1, key-define2: caption2, ...} >
		{"a": "foo", "b": "bar", "c1": "baz", "c2": "qux"}
<	この場合、"a : foo" "b : bar" "c1 : baz" "c2 : qux" という選択肢が示さ
	れ、例えば "b" を入力すると ["b", "baz"] というリストが返される。"c1"
	"c2" のような複数ストローク選択肢は選択が一意になるまで入力を受け取る
	。
	{choices}はリストでもよく、その場合はリストのリストで、次のように定義
	する。
	[ [key-define1, caption1], [key-define2, caption2], ...]
	辞書の場合と違って選択肢の並びを自由に設定できる。その場合、先ほどの例
	は、 >
		[["a", "foo"], ["b", "bar"], ["c1", "baz"], ["c2", "qux"]]
<	となる。

	また、リストのリストは第3要素以降を持つことが出来る。 >
		[["a", "foo"], ["b", "bar", {"hoge": 6}],
		\ ["c1", "baz", "L"], ["c2", "qux", ["piyo"], {"fuga": 44}]]
<	第3要素以降はどのような型でも良い。これらは処理上は無視されるが、返り
	値には現れる。

	また、選択肢の caption 部分は文字列だけでなく辞書やリストでも定義する
	ことが出来る。辞書で持たせる場合、関数の戻り値の第2要素はこの辞書の
	captionキーの値である(未定義なら空文字)。
	辞書には次のキーを持たせてもよい。
	--------~
	caption		(文字列)
		選択肢として表示される説明部分の文字。未定義の場合、その候補は
		選択肢に表示されない。選択は可能。
	is_hidden	(数値)
		既定値: 0
		非0 ならこの候補は選択肢に表示されない。選択は可能。
		caption キーを省いた場合と同じである。
	throw		(文字列)
		この選択肢が選ばれたときに、この文字列の例外を投げる。
	--------~
	この形式を使った{choices}の書き方はリストの場合以下のようになる。 >
		[
		\ ["a", {"caption": "foo"}],
		\ ["b", "bar"],
		\ ["\<C-a>", {"caption": "push <C-a>", "throw": "CTRL-A"}],
		\ ["q", {"caption": "qux", "is_hidden": 1}],
		\ ["r", {}],
		]
<	この場合、選択肢に "q" "r" は表示されないが選択は出来る。また、<C-a>
	を選択すると例外 "CTRL-A" が投げられる。

	captionをリストにする場合、リストの第1要素がcaptionとして扱われ、第2引
	数以降は処理上無視されるが、戻り値には第3引数以降として現れる。 >
		{
		\ "a": [{"caption": "foo"}, "Alice"],
		\ "b": ["bar", "Bob"],
		\ "\<C-a>": {"caption": "push <C-a>", "throw": "CTRL-A"},
		\ "q": [{"caption": "qux", "is_hidden": 1}, "Fred"],
		\ "r": {},
		}

<	省略可能な辞書{funcopts}(辞書)で関数の挙動を変更できる。
	--------~
	show_choices		(数値)
		既定値: 1
		0 にすると選択肢を表示しない。
	cancel_inputs		(リスト)
		既定値: ["\<Esc>"]
		このリストにある入力を受け取った場合、選択をキャンセルして関数
		を抜ける。安全のためにこのリストに必ず "\<C-c>" が加えられる。
		{choices}よりも優先される。戻り値は [] になる。
	throw_on_canceled	(数値/リスト)
		既定値: 0
		非0 にすると cancel_inputs が押されてキャンセルされる時に
		"select: canceled" の例外が投げられる。
		リストにすると、リストに定義されている要素の入力の時だけ例外が
		投げられる。例えば ["\<C-c>"] と定義されていた場合、<Esc>で抜
		けたときには例外が投げられない。<C-c>の時だけ投げられる。


lim#ui#keybind({binddefs})			*lim#ui#keybind()*


------------------------------------------------------------------------------
lim-modules-silo				*lim-modules-silo*

テーブル1つの簡易なデータベースを提供する。これは silo と呼び、文字列しか格納
できず、大きなデータの保持には向かない。これが向いているのはVimプラグインの少
し込み入った設定を永続化するときである。
|g:lim#silo#rootdir|で定義されるディレクトリ以下に silo で管理するデータのファ
イルが作成される。
使用実績) oreo.vim

lim#silo#newSilo({name}, {fields})		*lim#silo#newSilo()*
	任意の silo名{name}とフィールド名を表すリスト{fields}を受け取り、Silo
	オブジェクトを返す。このとき{name}の silo が既に存在する場合はそれを読
	み込む。
	ファイルの読み書きはこの Siloオブジェクト作成時と、commitメソッド呼び
	出し時以外には行われない。Siloオブジェクトを作成してからcommitするまで
	が1つのトランザクションと見なすことも出来る。
	{fields}は空であってはならず、その要素は Vim の変数名として使えるもの
	すなわちアルファベットと数字とアンダーバーで構成されなければならず、数
	字が先頭に来てはならない。
	定義を変更したときには|lim#silo#alter()|などでデータファイル側も更新
	すること。

	Siloオブジェクトは以下のメソッドを持つ。

	is_changed()
	Silo が保持するレコードが、作成時から変更されたかどうかを返す。

	commit([{rollback-filename}])
	Siloオブジェクトが持つrecordをファイルに書き込む。
	変更がないとき (is_changed() が 0 のとき) には書き込まない。
	insert() や update() 等で変更を行ってもこれを呼ばないと実際に反映され
	ないので注意。
	{rollback-filename}を与えると、その名前のrollbackファイルも作成される
	。
	これは|lim#silo#rollback()|で変更を取り消しできる。

	has({where})
	条件{where}にマッチするレコードがあれば 1 なければ 0 を返す。{where}は
	辞書かリストか文字列である。
	辞書の場合、キーに{fields}で渡したフィールド名、値に正規表現パターンを
	指定する。ただしこの正規表現パターンに行頭行末記号 ^ $ は使えない。他
	にも使えないパターンがあるだろう。条件にマッチするレコードが検索される
	。
	リストの場合は、その要素は insert() メソッドに渡す形式と同じである。そ
	れに完全一致するものが検索される。
	文字列の場合は、レコード内部表現を直接その文字列でマッチにかける。

	select({where}, [{fmt}])
	条件{where}にマッチするレコードのリストを返す。{where}は辞書である。
	辞書のキーはフィールド名で、{fields}で渡した要素のいずれかと一致しなく
	てはいけない。
	辞書の値は正規表現パターン文字列である。has() メソッドのものと同じく、
	^ $ などのパターンが使えない。
	{where}を空辞書にした場合、条件無しと見なされ、全てのレコードが返され
	る。
	{fmt}は{fields}で指定した要素のうち任意のものを任意の順に並べたリスト
	であり、select()の返り値であるレコードはこの形式に従う。例えば >
		["field3", "field4", "field1"]
<	という{fmt}を渡すと、レコードはこの形式のリストになり、select()の返り
	値はリストインリストになる。また{fmt}の要素数が1の場合、レコードは文字
	列になり、select()の返り値はリストインリストではなくなる。。
	{fmt}が省略されるか空リストの時には順番そのままの全フィールドのレコー
	ド(リスト)が返される。

	select_distinct({where}, [{fmt}])
	select()と同じだが、重複レコードは除外されて返される。
	|misc|モジュール|lim#misc#uniqify()|に依存する。

	exclude({where}, [{fmt}])
	select() メソッドが肯定なのに対しこれは否定で検索する。

	insert({record})
	insert({records})
	{record}が既に登録されているものと重複しないならばsiloに{record}を追加
	する。レコード{record}は文字列のリストか、文字列のリストのリスト
	{records}である。文字列のリストのリスト{records}にした場合、複数レコー
	ドの登録ができる。レコードは文字列のリストであり、その順番や要素数は
	{fields}で渡した要素の順番や項目数と同数でなければならない。

	delete({where})
	siloから条件{where}にマッチするレコードを削除する。{where}は辞書または
	リストである。
	リストの場合は、その要素は insert() メソッドに渡す形式と同じである。そ
	れに完全一致するものが検索される。

	sort([{func}])
	自身を返す。レコードをソートする。{func}には|sort()|で使われるのと同じ
	ものを利用できる。どのレコードの値をソート時に優先するかを指定したい場
	合は、rearrange() メソッドでフィールドの並びを変更すること。

	create_nextkey({field})
	フィールド名{field}のレコードの中で最大のものに1を加えた数を返す。この
	レコードは数字で構成されている必要がある。

	rearrange({destfields})
	フィールドのリスト{destfields}の順にフィールドの並び順を変更する。自身
	を返す。


------------------------------------------------------------------------------
lim-modules-str2vimkeybind			*lim-modules-str2vimkeybind*

				*lim#str2vimkeybind#str2vimkeybind()*
lim#str2vimkeybind#str2vimkeybind({stroke})
	文字列{stroke}の内、"<CR>" や "<C-a>" など、Vim のヘルプで使われるキー
	バインド表記で表すことができるものがあるのならそれに置き換える。
	文字列を返す。


------------------------------------------------------------------------------
lim-modules-misc				*lim-modules-misc*

汎用のモジュールを提供する。

--------------------------------------
Vim:

lim#misc#get_sid([{path}])			*lim#misc#get_sid()*
	Vim script{path}の script id を返す。{path}を省略した場合、現在開いて
	いるファイルで検索される。マッチがなければ 0 を返す。


lim#misc#match_sids({pat})			*lim#misc#match_sids()*
	パターン{pat}にマッチする script id をリストで返す。


lim#misc#get_scriptname({sid})			*lim#misc#get_scriptname()*


--------------------------------------
Data:

lim#misc#uniqify({list})			*lim#misc#uniqify()*
	{list}内の重複した要素を除去し、結果を返す。{list}を直接変更するので、
	必要なら事前に|copy()|をしておくこと。


--------------------------------------
System:

lim#misc#path_encode({path})			*lim#misc#path_encode()*
	パス名{path}をファイル名として使える名前に変更する。
	= を == に、: を =+ に、/ や \ を =- に変換した結果を返す。


lim#misc#path_decode({fname})			*lim#misc#path_decode()*
	|lim#misc#path_encode()|で変換したパス名を元に戻した結果を返す。


		*lim#misc#get_plugins_root_and_name_and_actualname()*
lim#misc#get_plugins_root_and_name_and_actualname({path})
	Vim plugin の 1ファイル{path}が所属するプラグインの名前とルートディレ
	クトリを推測して返す。ルートディレクトリはその直下には "after"
	"autoload" "plugin" "syntax" "ftplugin" "ftdetect" のうちのいずれかが
	あるだろうという乱暴な理論に基づいて{path}を遡りながら推測される。
	プラグイン名は、見つけたルートディレクトリの名前がすなわちプラグイン名
	だろうという乱暴な理論に基づき推測される。
	ただし、実際にはルートディレクトリ名がプラグイン名を表していない場合も
	あるので plugin, syntax, autoload ディレクトリにある実際の Vim script
	ファイル名を見てそれもプラグイン名の候補 actualname として返す。
	[rootpath, pluginname, actualname] というリストを返す。




==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:
